/*
 * Academic License - for use in teaching, academic research, and meeting
 * course requirements at degree granting institutions only.  Not for
 * government, commercial, or other organizational use.
 *
 * noise_cancel_fixpt.c
 *
 * Code generation for function 'noise_cancel_fixpt'
 *
 */

/* Include files */
#include "rt_nonfinite.h"
#include "noise_cancel_wrapper_fixpt_fil.h"
#include "noise_cancel_fixpt.h"
#include "noise_cancel_wrapper_fixpt_fil_data.h"

/* Function Definitions */
void noise_cancel_fixpt(const emlrtStack *sp, const int16_T s[100], const
  int16_T n[100], int16_T e[90], int16_T *W, int16_T bhat[90])
{
  int32_T i;
  int16_T i0;
  int16_T b_i;
  int32_T c_i;
  int16_T c;
  int32_T b_c;
  int16_T c_c;
  int32_T d_c;
  int32_T i1;
  int32_T i2;
  int32_T i3;
  int32_T i4;
  int32_T i5;
  int32_T i6;
  int32_T i7;
  int32_T d_i;
  int32_T e_c;
  int32_T i8;
  int32_T i9;
  int32_T i10;
  int32_T i11;
  int32_T i12;

  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /*                                                                           % */
  /*            Generated by MATLAB 9.2 and Fixed-Point Designer 5.4           % */
  /*                                                                           % */
  /* %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% */
  /* UNTITLED Summary of this function goes here */
  /*    Detailed explanation goes here */
  /*  p=inputParser; */
  /*  argName='bhat W e'; */
  /*  default=[zeros(1,itno) zeros(1,size(bhat,1)) zeros(1,itno)] ; */
  /*  % argName1='W'; */
  /*  % default=zeros(1,size(bhat,1)); */
  /*  % argName2='e'; */
  /*  % default=zeros(1,itno); */
  /*  addOptional(p,argName,default); */
  *W = 0;
  memset(&bhat[0], 0, 90U * sizeof(int16_T));
  memset(&e[0], 0, 90U * sizeof(int16_T));

  /*  if nargin < 2 */
  /*    error('signal and noise are required inputs') */
  /*  end */
  /*   */
  /*  if nargin < 3 */
  /*    e = zeros(1,itno); */
  /*    W=zeros(1,size(bhat,1)); */
  /*    bhat=zeros(1,itno); */
  /*  end */
  /*   */
  /*  if nargin < 4 */
  /*    W=zeros(1,size(bhat,1)); */
  /*    bhat=zeros(1,itno); */
  /*  end */
  /*  if nargin < 5 */
  /*      bhat=zeros(1,itno); */
  /*  end */
  /*   */
  i = 1;
  while (i < 90) {
    i0 = (int16_T)i;
    if ((i0 & 512) != 0) {
      b_i = (int16_T)(i0 | -512);
    } else {
      b_i = i0;
    }

    if ((b_i & 1024) != 0) {
      c_i = (int16_T)(b_i | -1024);
    } else {
      c_i = (int16_T)(b_i & 1023);
    }

    i0 = (int16_T)(c_i + 1);
    if ((i0 & 1024) != 0) {
      c = (int16_T)(i0 | -1024);
    } else {
      c = (int16_T)(i0 & 1023);
    }

    if ((c & 4096) != 0) {
      b_c = (int16_T)(c | -4096);
    } else {
      b_c = (int16_T)(c & 4095);
    }

    i0 = (int16_T)(b_c - 1);
    if ((i0 & 4096) != 0) {
      c_c = (int16_T)(i0 | -4096);
    } else {
      c_c = (int16_T)(i0 & 4095);
    }

    if ((c & 4096) != 0) {
      d_c = (int16_T)(c | -4096);
    } else {
      d_c = (int16_T)(c & 4095);
    }

    i0 = (int16_T)(d_c - 1);
    if ((i0 & 4096) != 0) {
      i1 = (int16_T)(i0 | -4096);
    } else {
      i1 = (int16_T)(i0 & 4095);
    }

    *W = n[i1 - 1];
    i2 = s[b_i - 1] << 4;
    i3 = n[c_c - 1] * bhat[b_i - 1];
    if ((i3 & 134217728) != 0) {
      i4 = i3 | -134217728;
    } else {
      i4 = i3 & 134217727;
    }

    i0 = (int16_T)(i4 >> 11);
    if ((i0 & 8192) != 0) {
      i3 = (int16_T)(i0 | -8192);
    } else {
      i3 = (int16_T)(i0 & 8191);
    }

    if ((i2 & 262144) != 0) {
      i5 = i2 | -262144;
    } else {
      i5 = i2 & 262143;
    }

    if ((i3 & 262144) != 0) {
      i6 = i3 | -262144;
    } else {
      i6 = i3 & 262143;
    }

    i2 = i5 - i6;
    if ((i2 & 262144) != 0) {
      i7 = i2 | -262144;
    } else {
      i7 = i2 & 262143;
    }

    i0 = (int16_T)(i7 >> 4);
    if ((i0 & 8192) != 0) {
      e[b_i - 1] = (int16_T)(i0 | -8192);
    } else {
      e[b_i - 1] = (int16_T)(i0 & 8191);
    }

    if ((b_i & 2048) != 0) {
      d_i = (int16_T)(b_i | -2048);
    } else {
      d_i = (int16_T)(b_i & 2047);
    }

    i0 = (int16_T)(d_i + 1);
    i2 = bhat[b_i - 1] << 15;
    c = e[b_i - 1];
    if ((c & 16384) != 0) {
      e_c = (int16_T)(c | -16384);
    } else {
      e_c = (int16_T)(c & 16383);
    }

    i3 = e_c * n[c_c - 1];
    if ((i3 & 268435456) != 0) {
      i3 |= -268435456;
    } else {
      i3 &= 268435455;
    }

    if ((i2 & 536870912) != 0) {
      i8 = i2 | -536870912;
    } else {
      i8 = i2 & 536870911;
    }

    if ((i3 & 536870912) != 0) {
      i9 = i3 | -536870912;
    } else {
      i9 = i3 & 536870911;
    }

    i2 = i8 + i9;
    if ((i2 & 536870912) != 0) {
      i10 = i2 | -536870912;
    } else {
      i10 = i2 & 536870911;
    }

    c = (int16_T)(i10 >> 15);
    if ((c & 8192) != 0) {
      if ((i0 & 2048) != 0) {
        i12 = (int16_T)(i0 | -2048);
      } else {
        i12 = (int16_T)(i0 & 2047);
      }

      bhat[i12 - 1] = (int16_T)(c | -8192);
    } else {
      if ((i0 & 2048) != 0) {
        i11 = (int16_T)(i0 | -2048);
      } else {
        i11 = (int16_T)(i0 & 2047);
      }

      bhat[i11 - 1] = (int16_T)(c & 8191);
    }

    i++;
    if (*emlrtBreakCheckR2012bFlagVar != 0) {
      emlrtBreakCheckR2012b(sp);
    }
  }
}

/* End of code generation (noise_cancel_fixpt.c) */
